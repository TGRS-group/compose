<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Compose-notebook</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
</head>
<body>
<div id="default"></div>

<script id="compose">
//+ _mainHtml {"type": "html", "target": "default"}
// <h3>Compose notebook </h3>
//  <input type="text" id="label" value="Untitled" style="margin: 5px;font-size:18pt;" title="Rename">
//  <input type="checkbox" id="show_hidden_cells">Show hidden cells</checkbox>
// <button onclick="{storeCellsAsBlocks();execute()}" title="Run all cells" class="material-symbols-outlined" >fast_forward</button>
// <button onclick="{save()}" title="Download" class="material-symbols-outlined" >save</button>
//  <div id="notebook_content">
//  </div>
//  <div id="outputPanel">
//  </div>
//+ _outputHtml {"type": "html", "target": "outputPanel"}
// <div id="output"></div>
// <svg id="svgOutput" width="100%" height="100%" style="flex-grow: 1; transform: scaleY(-1);" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
// </svg>

//+ _style {"type": "css"}
// textarea {padding: 5px; width: 100%; box-sizing: border-box;}
// .cell_seperator {opacity: 0; color: #ccc;}
// .cell_seperator:hover {opacity: 1; color: #ccc;}
// .cell {border: 1px solid #ddd;}
// .cell:hover {background-color: #eee; border: 1px solid #ccc;}
// .cell:hover + .cell_seperator {opacity: 1; color: #ccc;}
// .material-symbols-outlined {
//   font-family: 'Material Symbols Outlined';
//   font-size: 1em;
//   vertical-align: middle;
// }
// body {font-family: Arial, sans-serif;}

//+ _initializationCode
// textarea.cell_body {height: expression(this.scrollHeight + "px");}
var dirty = false;
if(typeof(shouldSave) !== 'undefined' && shouldSave) {
  save();
  shouldSave = false;
}

function updateTextArea(text, direction = null) {
  textarea = document.getElementById('editor');
  textarea.style.direction = 'ltr';
  if(direction && direction == 'rtl') {
    textarea.style.direction = 'rtl';
  }
  textarea.value = text;
  textarea.style.height = Math.min(textarea.scrollHeight, 20 * 16) + 'px';
}


function updateScript(text) {
  let script = document.createElement('script');
  script.id = 'compose';
  let scriptText = document.createTextNode(text);
  script.appendChild(scriptText);
  document.body.appendChild(script);
}

function editableBlockContent(type, storableContent) {
  if(type == 'javascript')
    return storableContent;
  let lines = storableContent.split('\n');
  let result = '';
  for(const line of lines) {
    if(line.match(/^\/\//)) {
      result += line.substring(2) + '\n';
    }
  }
  return result;
}

function storableBlockContent(type, editableContent) {
  if(type == 'javascript') {
    return editableContent;
  }
  let lines = editableContent.split('\n');
  let result = '';
  for(const line of lines) {
    result += '//' + line + '\n';
  }
  return result;
}

function parseHeader(line) {
  if(!line.trim().match(/^\/\/\+[ ]*[a-zA-Z0-9_]+/))
    return null;
  let blockName = line.match(/[a-zA-Z0-9_]+/)[0];
  let blockAttributes = JSON.parse((line.match(/\{.*\}/) || ['{"type": "javascript"}'])[0]);
  return { "name": blockName, "attributes": blockAttributes };
}

function trimScript(text) {
  text = text.split('\/\/--BEGIN');
  text = text[text.length - 1].split('\/\/--END')[0];
  return text.trim();
}

function parseBlocks(text) {
  var blocks = {};
  var lines = trimScript(text).split('\n');
  var blockName = '';
  for(const line of lines) {
    header = parseHeader(line);
    if(header) {
      blocks[header.name] = { "attributes": header.attributes, "content": ''};
      blockName = header.name;
      continue;
    }
    blocks[blockName].content += line + '\n';
  }
  return blocks;
}

function stringifyBlocks(blocks) {
  var text = '';
  for(const blockName of Object.keys(blocks)) {
    text += '//+ ' + blockName + JSON.stringify(blocks[blockName].attributes) + '\n';
    text += blocks[blockName].content;
  }
  return text;
}

function store() {
  let label = document.getElementById('label').value;
  let timestamp = (new Date()).toISOString().substring(0, 19);
  let content = stringifyBlocks(blocks);
  for (let i = 0; i < localStorage.length; i++){
    if(localStorage.getItem(localStorage.key(i)) == content && localStorage.key(i).startsWith(label)) {
      return;
    }
  }
  localStorage.setItem(label + ' ' + timestamp, content);
}

function storeBlock() {
  let blockName = document.getElementById('blockNames').value;
  let blockContent = document.getElementById('editor').value;
  blocks[blockName].content = storableBlockContent(blocks[blockName].attributes.type, blockContent);
  store();
  dirty = true;
}

function storeWholeScript() {
  let updated_script = document.getElementById('editor').value;
  blocks = parseBlocks(updated_script);
  store();
}

function execute() {
  Array.from(document.head.getElementsByTagName('style')).forEach(element => element.remove());
  currentScript = document.getElementById('compose').innerHTML;
  newScript = stringifyBlocks(blocks);
  document.body.innerHTML = '<div id="default"></div>';
  try{
    new Function(newScript); // check if the script is valid
    updateScript(`
      try { initialized = false;
      \/\/--BEGIN
      ${newScript}
      \/\/--END
       } catch(e) {
         alert('Error while executing updated script\\n'+ e + '\\n' + e.stack);
         if(! initialized) {
           document.getElementById('compose').remove();
           let script = document.createElement('script');
           script.id = 'compose';
           let scriptText = document.createTextNode(currentScript);
           script.appendChild(scriptText);
           document.body.appendChild(script);
         }
       }
    `);
  } catch(e) {
    alert('Updated script is not valid\n'+ e);
    updateScript(trimScript(currentScript));
  }
}

onSelectWholeScript = function() {
  document.getElementById('checkpoints').style.display = 'none';
  document.getElementById('blockNames').style.display = 'none';
  updateTextArea(stringifyBlocks(blocks));
  document.getElementById('store').onclick = function() {
    storeWholeScript();
  }
  document.getElementById('execute').onclick = function() {
    storeWholeScript();
    execute();
  }
}

onSelectBlock = function() {
  document.getElementById('checkpoints').style.display = 'none';
  let blockNames = Object.keys(blocks);
  let select = document.getElementById('blockNames');
  select.options.length = 0;
  select.style.display = 'block';
  for(const blockName of Object.keys(blocks)) {
    let option = document.createElement('option');
    option.value = blockName;
    option.innerHTML = blockName;
    select.appendChild(option);
  }
  select.onchange = function() {
    let blockName = select.value;
    updateTextArea(editableBlockContent(blocks[blockName].attributes.type, blocks[blockName].content), blocks[blockName].attributes.direction);
  }
  document.getElementById('store').onclick = function() {
    storeBlock();
  }
  document.getElementById('execute').onclick = function() {
    storeBlock();
    execute();
  }
  updateTextArea(editableBlockContent(blocks[blockNames[0]].attributes.type, blocks[blockNames[0]].content));
}

onRestore = function() {
  document.getElementById('blockNames').style.display = 'none';
  let select = document.getElementById('checkpoints');
  select.options.length = 0;
  select.style.display = 'block';
  for(let key of Object.keys(localStorage)) {
    let option = document.createElement('option');
    option.value = key;
    option.innerHTML = key;
    select.appendChild(option);
  }
  select.onchange = function() {
    let label = select.value;
    let content = localStorage.getItem(label);
    blocks = parseBlocks(content);
    updateTextArea(stringifyBlocks(blocks));
  }
  document.getElementById('store').onclick = function() {
    storeWholeScript();
  }
  document.getElementById('execute').onclick = function() {
    storeWholeScript();
    execute();
  }
  updateTextArea(stringifyBlocks(blocks));
}

var blocks = parseBlocks(document.getElementById('compose').innerHTML);

for(let [blockName, block] of Object.entries(blocks)) {
  switch(block.attributes.type) {
    case 'html':
      let target = document.getElementById(block.attributes.target);
      if (block.attributes.direction == 'rtl') {
        target.style.direction = 'rtl';
      }
      target.innerHTML = editableBlockContent(block.attributes.type, block.content);
      break;
    case 'css':
      let style = document.createElement('style');
      style.innerHTML = editableBlockContent(block.attributes.type, block.content);
      document.head.appendChild(style);
      break;
  }
}

initialized = true;


//+ _figureFunctions
function Rect(x,y,width,height,strokeWidth) {
  rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
  rect.setAttribute("x",x);
  rect.setAttribute("y",y);
  rect.setAttribute("width",width);
  rect.setAttribute("height",height);
  rect.setAttribute("fill","none");
  rect.setAttribute("stroke","black");
  rect.setAttribute("stroke-width",strokeWidth || "1");
  document.getElementById("svgOutput").appendChild(rect);
  return rect;
}

function Circle(cx,cy,r) {
  circle = document.createElementNS("http://www.w3.org/2000/svg","circle");
  circle.setAttribute("cx",cx);
  circle.setAttribute("cy",cy);
  circle.setAttribute("r",r);
  circle.setAttribute("fill","none");
  circle.setAttribute("stroke","black");
  document.getElementById("svgOutput").appendChild(circle);
  return circle;
}

function Line(x1,y1,x2,y2) {
  line = document.createElementNS("http://www.w3.org/2000/svg","line");
  line.setAttribute("x1",x1);
  line.setAttribute("y1",y1);
  line.setAttribute("x2",x2);
  line.setAttribute("y2",y2);
  line.setAttribute("stroke","black");
  document.getElementById("svgOutput").appendChild(line);
  return line;
}

function xlim(xmin,width) {
  ymin = document.getElementById("svgOutput").getAttribute("viewBox").split(" ")[1];
  height = document.getElementById("svgOutput").getAttribute("viewBox").split(" ")[3];
  document.getElementById("svgOutput").setAttribute("viewBox",xmin+" "+ymin+" "+width+" "+height);
}

function ylim(ymin,height) {
  xmin = document.getElementById("svgOutput").getAttribute("viewBox").split(" ")[0];
  width = document.getElementById("svgOutput").getAttribute("viewBox").split(" ")[2];
  document.getElementById("svgOutput").setAttribute("viewBox",xmin+" "+ymin+" "+width+" "+height);
}

//+ _notebookSetup
getCellOutput = function(blockName) {
  cell = document.getElementById(blockName);
  return cell.getElementsByClassName('output')[0];
}

function javascriptBlockContentFromCellContent(blockName, editableContent) {
  return "{function print(string) {getCellOutput('" + blockName + "').innerHTML += string + '<br>';}\n" + editableContent + "\n } \n";
}

function javascriptBlockContentToCellEditableContent(cellContent) {
  return cellContent.split("\n").slice(1,-2).join("\n");
}

function cellViewedContentFromEditableBlockContent(type, editableContent) {
  let displayedContent = editableContent;
  switch(type) {
    case 'markdown':
      displayedContent = marked.parse(editableContent);
      break;
    case 'javascript':
      displayedContent = "<pre><code>" + javascriptBlockContentToCellEditableContent(editableContent) + "</code></pre>";
      break;
  }
  return displayedContent;
}

function cellEditableContentFromBlockEditableContent(type, editableContent) {
  let cellEditableContent = editableContent;
  switch(type) {
    case 'javascript':
      cellEditableContent = javascriptBlockContentToCellEditableContent(editableContent);
      break;
  }
  return cellEditableContent;
}

createCellBody = function(mode, attributes, editableContent) {
  switch(mode) {
    case 'edit':
      cellBody = document.createElement('textarea');
      cellBody.value = cellEditableContentFromBlockEditableContent(attributes.type, editableContent);
      break;
    case 'view':
      cellBody = document.createElement('div');
      cellBody.innerHTML = cellViewedContentFromEditableBlockContent(attributes.type, editableContent);
      break;
  }
  cellBody.className = 'cell_body';
  if(attributes.direction && attributes.direction == 'rtl') {
    cellBody.style.direction = 'rtl';
  }
  return cellBody;
}

function appendCellOutput(cell) {
  let output = document.createElement('div');
  output.className = 'output';
  cell.appendChild(output);
}

function setCellContent(mode, cell, type, attributes, editableContent) {
  if (cell.getElementsByClassName('cell_body').length > 0) {
    cell.removeChild(cell.getElementsByClassName('cell_body')[0]);
  }
  if (cell.getElementsByClassName('output').length > 0 && attributes.type != "javascript") {
    cell.removeChild(cell.getElementsByClassName('output')[0]);
  }
  let cellOutput = cell.getElementsByClassName('output')[0];
  let cellBody = createCellBody(mode, attributes, editableContent);
  cell.insertBefore(cellBody, cellOutput);
  if(mode == 'edit') {
    cellBody.style.height = '1px';
    cellBody.style.height = (cellBody.scrollHeight+5) + 'px';
  }
  if(cell.getElementsByClassName('output').length == 0 && attributes.type == "javascript") {
    appendCellOutput(cell);
  }
  if(mode == 'edit' && attributes.type == "javascript") {
     // getCellOutput(cell.id).style.display = 'none';
  }
  if(mode == 'view' && attributes.type == "javascript") {
     getCellOutput(cell.id).style.display = 'block';
     cellBody.style.display = 'none';
  }
}

function setHeaderMode(mode, cell) {
  let cellHeader = cell.getElementsByClassName('cell_header')[0];
  updateButton = cellHeader.getElementsByClassName('update_button')[0];
  typeSelector = cellHeader.getElementsByClassName('type_selector')[0];
  ltrButton = cellHeader.getElementsByClassName('ltr_button')[0];
  rtlButton = cellHeader.getElementsByClassName('rtl_button')[0];
  let executeButton = cellHeader.getElementsByClassName('execute_button')[0];
  ltrButton.style.display = 'none';
  rtlButton.style.display = 'none';
  executeButton.style.display = 'none';
  updateButton.style.display = 'none';
  typeSelector.style.display = 'none';
  if (mode == 'edit') {
    updateButton.style.display = 'inline';
    typeSelector.style.display = 'inline';
    if(blocks[cell.id].attributes && blocks[cell.id].attributes.type &&  blocks[cell.id].attributes.type == 'markdown') {
      ltrButton.style.display = 'inline';
      rtlButton.style.display = 'inline';
    }
    if(blocks[cell.id].attributes && blocks[cell.id].attributes.type &&  blocks[cell.id].attributes.type == 'javascript') {
      executeButton.style.display = 'inline';
    }
  }
}

function updateBlockContentFromCellContent(blockName, cellContent) {
  let type = blocks[blockName].attributes.type;
  let blockContent = cellContent;
  if(type == 'javascript') {
    blockContent = javascriptBlockContentFromCellContent(blockName, cellContent);
  }
  blocks[blockName].content = storableBlockContent(type, blockContent);
  dirty = true;
}

function updateCell(cell) {
  let editableContent = cell.getElementsByClassName('cell_body')[0].value;
  updateBlockContentFromCellContent(cell.id, editableContent);
  store();
}

function createCellHeader(contentAttributes) {
  let cellHeader = document.createElement('div');
  cellHeader.className = 'cell_header';
  let editButton = document.createElement('button');
  editButton.className = 'edit_button';
  editButton.classList.add('material-symbols-outlined');
  editButton.innerHTML = 'edit';
  editButton.title = 'Edit cell content';
  let viewButton = document.createElement('button');
  viewButton.className = 'view_button';
  viewButton.classList.add('material-symbols-outlined');
  viewButton.innerHTML = 'visibility';
  viewButton.title = 'View';
  cellHeader.appendChild(editButton);
  cellHeader.appendChild(viewButton);
  editButton.onclick = function() {
    let cell = editButton.parentElement.parentElement;
    setHeaderMode('edit', cell);
    setCellContent('edit', cell, contentAttributes.type, contentAttributes, editableBlockContent(contentAttributes.type, blocks[cell.id].content));
    editButton.style.display = 'none';
    viewButton.style.display = 'inline';
  }
  viewButton.onclick = function() {
    let cell = viewButton.parentElement.parentElement;
    updateCell(cell);
    setHeaderMode('view', cell);
    setCellContent('view', cell, contentAttributes.type, contentAttributes, editableBlockContent(contentAttributes.type, blocks[cell.id].content));
    editButton.style.display = 'inline';
    viewButton.style.display = 'none';
  }
  viewButton.style.display = 'none';
  let deleteButton = document.createElement('button');
  deleteButton.className = 'delete_button';
  deleteButton.classList.add('material-symbols-outlined');
  deleteButton.innerHTML = 'delete';
  deleteButton.title = 'Delete cell';
  deleteButton.onclick = function() {
    let cell = deleteButton.parentElement.parentElement;
    let seperator = cell.nextElementSibling;
    let blockName = cell.id;
    delete blocks[blockName];
    cell.parentElement.removeChild(cell);
    if(seperator && seperator.className == 'seperator') {
      seperator.parentElement.removeChild(seperator);
    }
  }
  cellHeader.appendChild(deleteButton);

  let updateButton = document.createElement('button');
  updateButton.className = 'update_button';
  updateButton.classList.add('material-symbols-outlined');
  updateButton.innerHTML = 'download';
  updateButton.title = 'Update cell content';
  updateButton.onclick = function() {
    let cell = updateButton.parentElement.parentElement;
    updateCell(cell);
  }
  cellHeader.appendChild(updateButton);

  let executionButton = document.createElement('button');
  executionButton.className = 'execute_button';
  executionButton.classList.add('material-symbols-outlined');
  executionButton.innerHTML = 'play_arrow';
  executionButton.title = 'Execute cell';
  executionButton.onclick = function() {
    let cell = executionButton.parentElement.parentElement;
    if(blocks[cell.id].attributes && blocks[cell.id].attributes.type != 'javascript') {
      return;
    }
    updateCell(cell);
    let output = getCellOutput(cell.id);
    output.innerHTML = '';
    new Function(blocks[cell.id].content)();
  }
  cellHeader.appendChild(executionButton);

  let typeSelector = document.createElement('select');
  typeSelector.className = 'type_selector';
  let types = ['markdown', 'javascript'];
  for(let type of types) {
    let option = document.createElement('option');
    option.value = type;
    option.innerHTML = type;
    typeSelector.appendChild(option);
  }
  typeSelector.value = contentAttributes.type;
  typeSelector.onchange = function() {
    //let fromType = contentAttributes.type;
    // convert content of block and cell to new type
    let cell = typeSelector.parentElement.parentElement;
    contentAttributes.type = typeSelector.value;
    blocks[cell.id].attributes.type = typeSelector.value;
    updateBlockContentFromCellContent(cell.id, cell.getElementsByClassName('cell_body')[0].value);
    setHeaderMode('edit', cell);
    setCellContent('edit', cell, contentAttributes.type, contentAttributes, editableBlockContent(contentAttributes.type, blocks[cell.id].content));
  }
  cellHeader.appendChild(typeSelector);
  let ltr = document.createElement('button');
  ltr.className = 'ltr_button';
  ltr.title = 'Set text direction to left-to-right';
  ltr.classList.add('material-symbols-outlined');
  ltr.innerHTML = 'format_textdirection_l_to_r';


  ltr.onclick = function() {
    this.style.borderStyle = 'inset';
    rtl.style.borderStyle = 'outset';
    let cell = ltr.parentElement.parentElement;
    contentAttributes.direction = 'ltr';
    setCellContent('edit', cell, contentAttributes.type, contentAttributes, editableBlockContent(contentAttributes.type, blocks[cell.id].content));
  }
  cellHeader.appendChild(ltr);
  let rtl = document.createElement('button');
  rtl.className = 'rtl_button';
  rtl.title = 'Set text direction to right-to-left';
  rtl.classList.add('material-symbols-outlined');
  rtl.innerHTML = 'format_textdirection_r_to_l';
  rtl.onclick = function() {
    this.style.borderStyle = 'inset';
    ltr.style.borderStyle = 'outset';
    let cell = rtl.parentElement.parentElement;
    contentAttributes.direction = 'rtl';
    setCellContent('edit', cell, contentAttributes.type, contentAttributes, editableBlockContent(contentAttributes.type, blocks[cell.id].content));
  }
  cellHeader.appendChild(rtl);

  if(contentAttributes.type != 'markdown') {
    ltr.style.display = 'none';
    rtl.style.display = 'none';
  }
  if(contentAttributes.type != 'javascript') {
    executionButton.style.display = 'none';
  }
  return cellHeader;
}

function createCell(blockName, contentAttributes, cellContent) {
  let cell = document.createElement('div');
  cell.className = 'cell';
  cell.id = blockName;
  let cellHeader = createCellHeader(contentAttributes);
  cell.appendChild(cellHeader);
  setHeaderMode('view', cell);
  return cell;
}

function appendCell(blockName, contentAttributes, cellContent) {
  let cell = createCell(blockName, contentAttributes, cellContent);

  document.getElementById('notebook_content').appendChild(cell);
  setCellContent('view', cell, contentAttributes.type, contentAttributes, cellContent);

  if(blockName.startsWith('_') && document.getElementById('show_hidden_cells').checked == false) {
    cell.style.display = 'none';
  } else {
    appendCellSeperator();
  }
}

function insertCell(seperator, blockName, attributes, cellContent)
{
  let cell = createCell(blockName, attributes, cellContent);
  /* 
  let precedingCell = seperator.previousElementSibling;
  while (precedingCell != null && precedingCell.className != 'cell') {
    precedingCell = precedingCell.previousElementSibling;
  }
  if (precedingCell != null) {
    let precedingCellName = precedingCell.id;
    cellNames.splice(cellNames.indexOf(precedingCellName)+1, 0, blockName);

  }*/
  seperator.parentElement.insertBefore(cell, seperator);
  setCellContent('view', cell, attributes.type, attributes, cellContent);
}

function generateBlockName() {
  let i = 0;
  while(blocks["cell_"+i] != undefined) {
    i++;
  }
  return "cell_"+i;
}

function createAddCellButton(parent) {
  let addCellButton = document.createElement('button');
  addCellButton.className = 'add_cell_button';
  addCellButton.classList.add('material-symbols-outlined');
  addCellButton.innerHTML = 'add';
  addCellButton.title = 'Insert new cell';
  addCellButton.onclick = function() {
    let blockName = generateBlockName();
    blocks[blockName] = {
      attributes: {
        type: 'javascript',
      },
      content: storableBlockContent('javascript', '\/\/ '+blockName+'\n\n')
    };
    insertSeperator(parent);
    insertCell(parent, blockName, blocks[blockName].attributes, editableBlockContent(blocks[blockName].attributes.type, blocks[blockName].content));
  }
  return addCellButton;
}

function createSeperator() {
  let seperator = document.createElement('div');
  seperator.className = 'seperator';
  let add = createAddCellButton(seperator);
  seperator.appendChild(add);
  return seperator;
}

function insertSeperator(caller) {
  let seperator = createSeperator();
  caller.parentElement.insertBefore(seperator, caller);
}

function appendCellSeperator() {
  let seperator = createSeperator();
  document.getElementById('notebook_content').appendChild(seperator);
}

// cellNames = [];

function renderCellsFromBlocks() {
  appendCellSeperator();
  for(let [blockName, block] of Object.entries(blocks)) {
    appendCell(blockName, block.attributes, editableBlockContent(block.attributes.type, block.content));
    // cellNames.push(blockName);
  }
}

function storeCellsAsBlocks() {
  let cells = document.getElementsByClassName('cell');
  let updatedBlocks = {};
  for(let cell of cells) {
    let blockName = cell.id;
    let contentAttributes = blocks[blockName].attributes;
    updatedBlocks[blockName] = {
      attributes: contentAttributes,
      content: blocks[blockName].content,
    };
  }
  blocks = updatedBlocks;
  dirty = true;
}


//+ _specificSetup
function setOutput(text) {
  document.getElementById("output").innerHTML=text;
}

function print(text) {
  document.getElementById("output").innerHTML += text;
}
function save() {
  if(dirty) {
    alert("Entire notebook must be executed before saving.");
    return;
 }

 let label = document.getElementById('label').value;
 // shouldSave = true;
 const data = "<!DOCTYPE html>\n"+document.documentElement.outerHTML;
 const link = document.createElement('a');
 link.setAttribute('download', label+'.html');
 link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(data));
 link.style.display = 'none';
 link.click();
}

//+ _initialize
renderCellsFromBlocks();
let label = document.getElementById('label').value;
document.title = label;
document.getElementById('label').onchange = function() {
  document.title = document.getElementById('label').value;
}

document.getElementById('show_hidden_cells').onchange = function() {
  for(let cell of document.getElementsByClassName('cell')) {
    if(cell.id.startsWith('_')) {
      if(document.getElementById('show_hidden_cells').checked) {
        cell.style.display = 'block';
      } else {
        cell.style.display = 'none';
      }
    }
  }
}
// cells should have mode (edit, view, hidden)
// cells should have a button to move up
// cells should have a button to move down
// cells should have a button to delete
// cells should have a button to insert above
// cells should have a button to insert below
// cells should have a button to duplicate
//+ markdowntest {"type": "markdown"}
// # Heading
//+ computeCode
{function print(string) {getCellOutput('computeCode').innerHTML += string + '<br>';}
// JS code here. Call print(text) to print output on the output panel
}

</script>
</body>
</html>
